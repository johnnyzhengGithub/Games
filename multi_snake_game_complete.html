<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¶…çº§å¤šè›‡å¤§ä½œæˆ˜</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-y: auto;
        }

        .scroll-wrapper {
            max-height: 100vh;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 95vw;
            max-height: 95vh;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #fff, #f0f0f0, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.5)); }
            to { filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)); }
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            border-radius: 15px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .player-stat { background: rgba(46, 213, 115, 0.3); }
        .ai-stat { background: rgba(255, 71, 87, 0.3); }
        .neutral-stat { background: rgba(255, 159, 67, 0.3); }
        .boss-stat { background: rgba(138, 43, 226, 0.3); }

        #gameCanvas {
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 20px;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.7));
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            margin: 15px 0;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 0.9rem;
            border-radius: 20px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(-1px);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        .danger { background: linear-gradient(45deg, #ff4757, #ff3742); }
        .warning { background: linear-gradient(45deg, #ffa502, #ff9500); }
        .special { background: linear-gradient(45deg, #9c88ff, #8c7ae6); }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .setting-group select, .setting-group input {
            width: 100%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 5px 8px;
            font-size: 0.9rem;
        }

        .setting-group option {
            background: #333;
            color: white;
        }

        .instructions {
            font-size: 0.8rem;
            opacity: 0.9;
            line-height: 1.4;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 15px;
            margin-top: 15px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 5px;
        }

        .game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            max-width: 400px;
            animation: popIn 0.5s ease-out;
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .game-over h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        @media (max-width: 700px) {
            .game-container {
                padding: 15px;
                margin: 5px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            #gameCanvas {
                width: 350px;
                height: 350px;
            }
            
            .stats-container {
                grid-template-columns: repeat(2, 1fr);
                font-size: 0.8rem;
            }
        }

        .power-up {
            animation: pulse 1s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
    </style>
</head>
<body>
<div class="scroll-wrapper">
    <div class="game-container">
        <h1>ğŸ è¶…çº§å¤šè›‡å¤§ä½œæˆ˜ ğŸ†</h1>
        
        <div class="stats-container">
            <div class="stat-item player-stat">ç©å®¶: <span id="playerScore">0</span></div>
            <div class="stat-item ai-stat">æ™ºèƒ½è›‡: <span id="aiScore">0</span></div>
            <div class="stat-item neutral-stat">ä¸­ç«‹è›‡: <span id="neutralScore">0</span></div>
            <div class="stat-item boss-stat">Bossè›‡: <span id="bossScore">0</span></div>
            <div class="stat-item">å­˜æ´»: <span id="aliveCount">4</span>/4</div>
            <div class="stat-item">æœ€é«˜åˆ†: <span id="highScore">0</span></div>
        </div>

        <div class="settings">
            <div class="setting-group">
                <label for="gameSpeed">æ¸¸æˆé€Ÿåº¦:</label>
                <select id="gameSpeed">
                    <option value="200">æ…¢é€Ÿ</option>
                    <option value="120" selected>ä¸­é€Ÿ</option>
                    <option value="80">å¿«é€Ÿ</option>
                    <option value="50">æé€Ÿ</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="snakeCount">AIè›‡æ•°é‡:</label>
                <select id="snakeCount">
                    <option value="2">2æ¡</option>
                    <option value="3" selected>3æ¡</option>
                    <option value="4">4æ¡</option>
                    <option value="5">5æ¡</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="powerUpEnabled">é“å…·ç³»ç»Ÿ:</label>
                <select id="powerUpEnabled">
                    <option value="true" selected>å¼€å¯</option>
                    <option value="false">å…³é—­</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="bossMode">Bossæ¨¡å¼:</label>
                <select id="bossMode">
                    <option value="true" selected>å¼€å¯</option>
                    <option value="false">å…³é—­</option>
                </select>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="800"></canvas>

        <div class="controls">
            <button onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
            <button onclick="pauseGame()" class="warning">æš‚åœ/ç»§ç»­</button>
            <button onclick="resetGame()" class="danger">é‡æ–°å¼€å§‹</button>
            <button onclick="toggleAI()" class="special">AIå¯¹æˆ˜</button>
        </div>

        <div class="instructions">
            <h3>ğŸ® æ¸¸æˆè¯´æ˜</h3>
            <p>â€¢ ä½¿ç”¨æ–¹å‘é”®æˆ–WASDæ§åˆ¶ç»¿è‰²ç©å®¶è›‡</p>
            <p>â€¢ ä¸å¤šæ¡ä¸åŒç±»å‹çš„AIè›‡ç«äº‰</p>
            <p>â€¢ æ”¶é›†é£Ÿç‰©å’Œé“å…·æ¥å¢å¼ºå®åŠ›</p>
            <p>â€¢ é¿å…æ’å¢™ã€æ’åˆ°è‡ªå·±æˆ–å…¶ä»–è›‡</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ed573;"></div>
                    <span>ç©å®¶è›‡</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4757;"></div>
                    <span>æ™ºèƒ½è›‡</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffa502;"></div>
                    <span>ä¸­ç«‹è›‡</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #8c7ae6;"></div>
                    <span>Bossè›‡</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b9d;"></div>
                    <span>æ™®é€šé£Ÿç‰©</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd700;"></div>
                    <span>é‡‘è‰²é£Ÿç‰©</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d2d3;"></div>
                    <span>é€Ÿåº¦é“å…·</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9ff3;"></div>
                    <span>æŠ¤ç›¾é“å…·</span>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2>æ¸¸æˆç»“æŸï¼</h2>
            <div id="gameResults"></div>
            <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // è·å–UIå…ƒç´ 
        const elements = {
            playerScore: document.getElementById('playerScore'),
            aiScore: document.getElementById('aiScore'),
            neutralScore: document.getElementById('neutralScore'),
            bossScore: document.getElementById('bossScore'),
            aliveCount: document.getElementById('aliveCount'),
            highScore: document.getElementById('highScore'),
            gameOver: document.getElementById('gameOver'),
            gameResults: document.getElementById('gameResults'),
            gameSpeed: document.getElementById('gameSpeed'),
            snakeCount: document.getElementById('snakeCount'),
            powerUpEnabled: document.getElementById('powerUpEnabled'),
            bossMode: document.getElementById('bossMode')
        };

        // æ¸¸æˆå¸¸é‡
        const GRID_SIZE = 18;
        const TILE_COUNT = Math.floor(canvas.width / GRID_SIZE);
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            running: false,
            paused: false,
            loop: null,
            speed: 120,
            highScore: 0,
            powerUpsEnabled: true,
            bossMode: true,
            aiOnly: false
        };

        // è›‡çš„ç±»å‹å®šä¹‰
        const SNAKE_TYPES = {
            PLAYER: {
                color: '#2ed573',
                shadowColor: '#2ed573',
                bodyColor: '#26d0ce',
                intelligence: 0,
                speed: 1,
                shape: 'round'
            },
            AI_SMART: {
                color: '#ff4757',
                shadowColor: '#ff4757',
                bodyColor: '#ff6b9d',
                intelligence: 8,
                speed: 1,
                shape: 'square'
            },
            AI_NEUTRAL: {
                color: '#ffa502',
                shadowColor: '#ffa502',
                bodyColor: '#ffb8b8',
                intelligence: 5,
                speed: 1,
                shape: 'diamond'
            },
            AI_BOSS: {
                color: '#8c7ae6',
                shadowColor: '#8c7ae6',
                bodyColor: '#a29bfe',
                intelligence: 10,
                speed: 0.7,
                shape: 'star',
                size: 1.3
            }
        };

        // é“å…·ç±»å‹
        const POWER_UP_TYPES = {
            SPEED: {
                color: '#00d2d3',
                effect: 'speed',
                duration: 5000,
                symbol: 'âš¡'
            },
            SHIELD: {
                color: '#ff9ff3',
                effect: 'shield',
                duration: 3000,
                symbol: 'ğŸ›¡ï¸'
            },
            GOLDEN_FOOD: {
                color: '#ffd700',
                effect: 'golden',
                duration: 0,
                symbol: 'â­'
            }
        };

        // æ¸¸æˆå¯¹è±¡
        let snakes = [];
        let foods = [];
        let powerUps = [];
        let particles = [];

        // ç²’å­ç³»ç»Ÿ
        class Particle {
            constructor(x, y, color, size = 3) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.color = color;
                this.size = size;
                this.life = 1;
                this.decay = 0.02;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
                this.size *= 0.99;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0 || this.size <= 0.5;
            }
        }

        // è›‡ç±»
        class Snake {
            constructor(x, y, type, id) {
                this.id = id;
                this.type = type;
                this.body = [{x, y}];
                this.dx = 0;
                this.dy = 0;
                this.score = 0;
                this.alive = true;
                this.powerUps = new Map();
                this.lastMove = 0;
                this.moveDelay = type === SNAKE_TYPES.AI_BOSS ? 140 : 100;
                
                // ä¸ºä¸åŒç±»å‹çš„è›‡è®¾ç½®åˆå§‹æ–¹å‘
                if (type !== SNAKE_TYPES.PLAYER) {
                    const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
                    const randomDir = directions[Math.floor(Math.random() * directions.length)];
                    this.dx = randomDir.dx;
                    this.dy = randomDir.dy;
                }
                
                // å¢åŠ AIçš„å®‰å…¨ç§»åŠ¨å»¶è¿Ÿ
                if (type !== SNAKE_TYPES.PLAYER) {
                    this.moveDelay = type === SNAKE_TYPES.AI_BOSS ? 150 : 100; // å‡å°‘å»¶è¿Ÿè®©AIæ›´ç§¯æ
                }
            }

            move() {
                if (!this.alive || gameState.paused) return;
                
                const now = Date.now();
                if (now - this.lastMove < this.moveDelay) return;
                this.lastMove = now;

                // AIç§»åŠ¨é€»è¾‘
                if (this.type !== SNAKE_TYPES.PLAYER && !gameState.aiOnly) {
                    this.aiMove();
                } else if (gameState.aiOnly && this.type === SNAKE_TYPES.PLAYER) {
                    this.aiMove();
                }

                if (this.dx === 0 && this.dy === 0) return;

                const head = this.body[0];
                const newHead = {
                    x: head.x + this.dx,
                    y: head.y + this.dy
                };

                // æ£€æŸ¥è¾¹ç•Œç¢°æ’
                if (newHead.x < 0 || newHead.x >= TILE_COUNT || 
                    newHead.y < 0 || newHead.y >= TILE_COUNT) {
                    this.die();
                    return;
                }

                // æ£€æŸ¥è‡ªèº«ç¢°æ’
                if (this.checkSelfCollision(newHead)) {
                    this.die();
                    return;
                }

                // æ£€æŸ¥ä¸å…¶ä»–è›‡çš„ç¢°æ’
                if (this.checkSnakeCollision(newHead)) {
                    // å¦‚æœæœ‰æŠ¤ç›¾ï¼Œæ¶ˆè€—æŠ¤ç›¾è€Œä¸æ˜¯æ­»äº¡
                    if (this.powerUps.has('shield')) {
                        this.powerUps.delete('shield');
                        this.createParticles(newHead.x * GRID_SIZE, newHead.y * GRID_SIZE, '#ff9ff3');
                    } else {
                        this.die();
                        return;
                    }
                }

                this.body.unshift(newHead);

                // æ£€æŸ¥é£Ÿç‰©ç¢°æ’
                let ateFood = false;
                for (let i = foods.length - 1; i >= 0; i--) {
                    if (foods[i].x === newHead.x && foods[i].y === newHead.y) {
                        this.score += foods[i].value || 10;
                        this.createParticles(newHead.x * GRID_SIZE, newHead.y * GRID_SIZE, foods[i].color);
                        foods.splice(i, 1);
                        ateFood = true;
                        generateFood();
                        break;
                    }
                }

                // æ£€æŸ¥é“å…·ç¢°æ’
                if (gameState.powerUpsEnabled) {
                    for (let i = powerUps.length - 1; i >= 0; i--) {
                        if (powerUps[i].x === newHead.x && powerUps[i].y === newHead.y) {
                            this.applyPowerUp(powerUps[i]);
                            powerUps.splice(i, 1);
                            ateFood = true;
                            break;
                        }
                    }
                }

                if (!ateFood) {
                    this.body.pop();
                }

                this.updatePowerUps();
            }

            aiMove() {
                const head = this.body[0];
                const intelligence = this.type.intelligence;

                // é¦–å…ˆæ£€æŸ¥å½“å‰æ–¹å‘çš„å³æ—¶å®‰å…¨æ€§
                const currentDirection = {x: head.x + this.dx, y: head.y + this.dy};
                const isCurrentSafe = currentDirection.x >= 0 && currentDirection.x < TILE_COUNT &&
                                    currentDirection.y >= 0 && currentDirection.y < TILE_COUNT &&
                                    !this.checkSelfCollision(currentDirection) &&
                                    !this.checkSnakeCollision(currentDirection);

                // å¦‚æœå½“å‰æ–¹å‘ä¸å®‰å…¨ï¼Œç«‹å³å¯»æ‰¾å®‰å…¨æ–¹å‘
                if (!isCurrentSafe) {
                    this.findBestSafeDirection();
                    return;
                }

                // æ ¹æ®æ™ºèƒ½ç­‰çº§è°ƒæ•´ç§¯ææ€§
                const aggressiveness = intelligence / 10; // 0.5 åˆ° 1.0
                const searchRadius = intelligence + 5; // æœç´¢åŠå¾„

                // å¯»æ‰¾ç›®æ ‡ - æ›´ç§¯æåœ°å¯»æ‰¾é£Ÿç‰©
                let bestTarget = null;
                let bestScore = -1;

                // è¯„ä¼°æ‰€æœ‰é£Ÿç‰©
                for (const food of foods) {
                    const distance = Math.abs(food.x - head.x) + Math.abs(food.y - head.y);
                    if (distance > searchRadius) continue; // é™åˆ¶æœç´¢èŒƒå›´
                    
                    // è®¡ç®—é£Ÿç‰©ä»·å€¼ï¼ˆè€ƒè™‘è·ç¦»å’Œä»·å€¼ï¼‰
                    let score = (food.value || 10) / (distance + 1);
                    
                    // é‡‘è‰²é£Ÿç‰©é¢å¤–å¥–åŠ±
                    if (food.value === 30) {
                        score *= 2;
                    }
                    
                    // æ£€æŸ¥è·¯å¾„æ˜¯å¦ç›¸å¯¹å®‰å…¨
                    if (this.isPathGenerallySafe(head, food, 3)) {
                        score *= 1.5; // å®‰å…¨è·¯å¾„å¥–åŠ±
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = food;
                    }
                }

                // è¯„ä¼°é“å…·ï¼ˆé«˜æ™ºèƒ½AIæ›´é‡è§†é“å…·ï¼‰
                if (intelligence > 6) {
                    for (const powerUp of powerUps) {
                        const distance = Math.abs(powerUp.x - head.x) + Math.abs(powerUp.y - head.y);
                        if (distance > 8) continue;
                        
                        let score = 50 / (distance + 1); // é“å…·åŸºç¡€ä»·å€¼é«˜
                        
                        // æ ¹æ®é“å…·ç±»å‹è°ƒæ•´
                        switch (powerUp.type.effect) {
                            case 'speed':
                                score *= 1.5;
                                break;
                            case 'shield':
                                score *= 1.3;
                                break;
                            case 'golden':
                                score *= 2.0;
                                break;
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = powerUp;
                        }
                    }
                }

                // å¦‚æœæ‰¾åˆ°å¥½ç›®æ ‡ï¼Œå°è¯•å‰å¾€
                if (bestTarget && bestScore > 0.5) {
                    const path = this.findPath(head, bestTarget, intelligence);
                    if (path && path.length > 0) {
                        const nextStep = path[0];
                        const newDx = nextStep.x - head.x;
                        const newDy = nextStep.y - head.y;
                        
                        // éªŒè¯æ–°æ–¹å‘çš„å®‰å…¨æ€§
                        const newPos = {x: head.x + newDx, y: head.y + newDy};
                        if (this.isDirectionSafe(newPos, newDx, newDy)) {
                            this.dx = newDx;
                            this.dy = newDy;
                            return;
                        }
                    }
                }

                // æ²¡æœ‰å¥½ç›®æ ‡æˆ–è·¯å¾„ä¸å®‰å…¨æ—¶çš„ç­–ç•¥
                // é«˜æ™ºèƒ½AIæ›´å€¾å‘äºæ¢ç´¢ï¼Œä½æ™ºèƒ½AIæ›´ä¿å®ˆ
                const explorationChance = aggressiveness * 0.3; // 0.15 åˆ° 0.3
                
                if (Math.random() < explorationChance) {
                    // æ¢ç´¢æ€§ç§»åŠ¨ - å¯»æ‰¾æ›´å¥½çš„ä½ç½®
                    this.findExplorationDirection();
                } else {
                    // å®‰å…¨ä½†ä¸å®Œå…¨é™æ­¢çš„ç§»åŠ¨
                    if (Math.random() < 0.1) {
                        this.findBestSafeDirection();
                    }
                }
            }

            // æ£€æŸ¥ä»èµ·ç‚¹åˆ°ç›®æ ‡çš„è·¯å¾„æ˜¯å¦å¤§è‡´å®‰å…¨
            isPathGenerallySafe(start, target, checkDepth) {
                const dx = target.x > start.x ? 1 : target.x < start.x ? -1 : 0;
                const dy = target.y > start.y ? 1 : target.y < start.y ? -1 : 0;
                
                let x = start.x;
                let y = start.y;
                
                for (let i = 0; i < checkDepth; i++) {
                    x += dx;
                    y += dy;
                    
                    if (x < 1 || x >= TILE_COUNT - 1 || y < 1 || y >= TILE_COUNT - 1) {
                        return false;
                    }
                    
                    if (this.checkSelfCollision({x, y}) || this.checkSnakeCollision({x, y})) {
                        return false;
                    }
                }
                
                return true;
            }

            // éªŒè¯æ–¹å‘æ˜¯å¦å®‰å…¨ï¼ˆåŒ…æ‹¬å‰ç»ï¼‰
            isDirectionSafe(newPos, dx, dy) {
                if (newPos.x < 0 || newPos.x >= TILE_COUNT || 
                    newPos.y < 0 || newPos.y >= TILE_COUNT) {
                    return false;
                }
                
                if (this.checkSelfCollision(newPos) || this.checkSnakeCollision(newPos)) {
                    return false;
                }
                
                // æ£€æŸ¥ä¸‹ä¸€æ­¥æ˜¯å¦ä¹Ÿå®‰å…¨
                const nextPos = {x: newPos.x + dx, y: newPos.y + dy};
                if (nextPos.x < 0 || nextPos.x >= TILE_COUNT || 
                    nextPos.y < 0 || nextPos.y >= TILE_COUNT) {
                    return false;
                }
                
                return !(dx === -this.dx && dy === -this.dy); // ä¸èƒ½åå‘
            }

            // æ¢ç´¢æ€§ç§»åŠ¨ - å¯»æ‰¾æ›´å¥½çš„ä½ç½®
            findExplorationDirection() {
                const head = this.body[0];
                const directions = [
                    { dx: 0, dy: -1, score: 0 },
                    { dx: 0, dy: 1, score: 0 },
                    { dx: -1, dy: 0, score: 0 },
                    { dx: 1, dy: 0, score: 0 }
                ];

                for (const dir of directions) {
                    const nx = head.x + dir.dx;
                    const ny = head.y + dir.dy;

                    // é¿å…åå‘ç§»åŠ¨
                    if (dir.dx === -this.dx && dir.dy === -this.dy) {
                        dir.score = -1000;
                        continue;
                    }

                    if (!this.isDirectionSafe({x: nx, y: ny}, dir.dx, dir.dy)) {
                        dir.score = -500;
                        continue;
                    }

                    // è®¡ç®—åˆ°æœ€è¿‘é£Ÿç‰©çš„è·ç¦»ï¼ˆé¼“åŠ±æ¥è¿‘é£Ÿç‰©ï¼‰
                    let minFoodDistance = Infinity;
                    for (const food of foods) {
                        const distance = Math.abs(food.x - nx) + Math.abs(food.y - ny);
                        minFoodDistance = Math.min(minFoodDistance, distance);
                    }
                    dir.score += (20 - minFoodDistance) * 2;

                    // å€¾å‘äºå‘åœ°å›¾ä¸­å¿ƒç§»åŠ¨ï¼ˆä½†ä¸å¼ºåˆ¶ï¼‰
                    const centerX = TILE_COUNT / 2;
                    const centerY = TILE_COUNT / 2;
                    const distanceToCenter = Math.abs(nx - centerX) + Math.abs(ny - centerY);
                    dir.score += (TILE_COUNT - distanceToCenter) * 1;

                    // è®¡ç®—å‰æ–¹ç©ºé—´
                    const freeSpace = this.calculateSafeSpace(nx, ny, dir.dx, dir.dy, 4);
                    dir.score += freeSpace * 3;

                    // æ·»åŠ éšæœºæ€§
                    dir.score += Math.random() * 10;
                }

                directions.sort((a, b) => b.score - a.score);
                
                if (directions[0].score > -500) {
                    this.dx = directions[0].dx;
                    this.dy = directions[0].dy;
                }
            }

            findPath(start, goal, searchDepth) {
                const openSet = [{
                    x: start.x,
                    y: start.y,
                    g: 0,
                    h: this.heuristic(start, goal),
                    f: 0,
                    parent: null
                }];
                
                const closedSet = new Set();
                const maxIterations = Math.min(searchDepth * 10, 100);
                let iterations = 0;

                while (openSet.length > 0 && iterations < maxIterations) {
                    iterations++;
                    
                    openSet.sort((a, b) => a.f - b.f);
                    const current = openSet.shift();
                    
                    const key = `${current.x},${current.y}`;
                    if (closedSet.has(key)) continue;
                    closedSet.add(key);

                    if (current.x === goal.x && current.y === goal.y) {
                        const path = [];
                        let node = current;
                        while (node.parent) {
                            path.unshift({x: node.x, y: node.y});
                            node = node.parent;
                        }
                        return path;
                    }

                    const neighbors = [
                        {x: current.x, y: current.y - 1},
                        {x: current.x, y: current.y + 1},
                        {x: current.x - 1, y: current.y},
                        {x: current.x + 1, y: current.y}
                    ];

                    for (const neighbor of neighbors) {
                        if (neighbor.x < 0 || neighbor.x >= TILE_COUNT || 
                            neighbor.y < 0 || neighbor.y >= TILE_COUNT) continue;

                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        if (closedSet.has(neighborKey)) continue;

                        // é¿å…åå‘ç§»åŠ¨
                        if (current.parent === null) {
                            const newDx = neighbor.x - current.x;
                            const newDy = neighbor.y - current.y;
                            if (newDx === -this.dx && newDy === -this.dy) continue;
                        }

                        if (this.isPositionDangerous(neighbor.x, neighbor.y)) continue;

                        const g = current.g + 1;
                        const h = this.heuristic(neighbor, goal);
                        const f = g + h;

                        const existingNode = openSet.find(node => 
                            node.x === neighbor.x && node.y === neighbor.y);
                        
                        if (!existingNode || g < existingNode.g) {
                            if (existingNode) {
                                existingNode.g = g;
                                existingNode.f = f;
                                existingNode.parent = current;
                            } else {
                                openSet.push({
                                    x: neighbor.x,
                                    y: neighbor.y,
                                    g: g,
                                    h: h,
                                    f: f,
                                    parent: current
                                });
                            }
                        }
                    }
                }

                return null;
            }

            buildSafetyMap() {
                const map = Array.from({ length: TILE_COUNT }, () => Array(TILE_COUNT).fill(0));
                for (let y = 0; y < TILE_COUNT; y++) {
                    for (let x = 0; x < TILE_COUNT; x++) {
                        if (this.isPositionDangerous(x, y)) {
                            map[y][x] = -100;
                        } else {
                            const edgePenalty = Math.min(x, TILE_COUNT - x, y, TILE_COUNT - y);
                            map[y][x] = edgePenalty;
                        }
                    }
                }
                return map;
            }

            findBestSafeDirection() {
                const head = this.body[0];
                
                const directions = [
                    { dx: 0, dy: -1, score: 0 },  // ä¸Š
                    { dx: 0, dy: 1, score: 0 },   // ä¸‹
                    { dx: -1, dy: 0, score: 0 },  // å·¦
                    { dx: 1, dy: 0, score: 0 }    // å³
                ];

                // ä¸ºæ¯ä¸ªæ–¹å‘è¯„åˆ†
                for (const dir of directions) {
                    const nx = head.x + dir.dx;
                    const ny = head.y + dir.dy;

                    // é¿å…åå‘ç§»åŠ¨
                    if (dir.dx === -this.dx && dir.dy === -this.dy) {
                        dir.score = -1000;
                        continue;
                    }

                    // æ£€æŸ¥åŸºæœ¬å®‰å…¨æ€§
                    if (!this.isDirectionSafe({x: nx, y: ny}, dir.dx, dir.dy)) {
                        dir.score = -800;
                        continue;
                    }

                    // è®¡ç®—å‰æ–¹è¿ç»­å®‰å…¨ç©ºé—´
                    const freeSpace = this.calculateSafeSpace(nx, ny, dir.dx, dir.dy, 5);
                    dir.score += freeSpace * 10;

                    // è®¡ç®—å‘¨å›´çš„è‡ªç”±åº¦
                    const freedom = this.calculateFreedom(nx, ny);
                    dir.score += freedom * 8;

                    // é¼“åŠ±æ¥è¿‘é£Ÿç‰©
                    let minFoodDistance = Infinity;
                    for (const food of foods) {
                        const distance = Math.abs(food.x - nx) + Math.abs(food.y - ny);
                        minFoodDistance = Math.min(minFoodDistance, distance);
                    }
                    if (minFoodDistance < Infinity) {
                        dir.score += (15 - minFoodDistance) * 1.5;
                    }

                    // é€‚é‡éšæœºæ€§
                    dir.score += Math.random() * 8;

                    // å¦‚æœå½“å‰æ–¹å‘å®‰å…¨ä¸”è¯„åˆ†ä¸é”™ï¼Œç»™äºˆè¿ç»­æ€§å¥–åŠ±
                    if (dir.dx === this.dx && dir.dy === this.dy && dir.score > 20) {
                        dir.score += 15;
                    }
                }

                // é€‰æ‹©æœ€ä½³æ–¹å‘
                directions.sort((a, b) => b.score - a.score);
                
                if (directions[0].score > -800) {
                    this.dx = directions[0].dx;
                    this.dy = directions[0].dy;
                }
            }

            // è®¡ç®—æŒ‡å®šä½ç½®å‘¨å›´çš„è‡ªç”±åº¦
            calculateFreedom(x, y) {
                let freeCount = 0;
                const checkPositions = [
                    {x: x-1, y: y}, {x: x+1, y: y},
                    {x: x, y: y-1}, {x: x, y: y+1},
                    {x: x-1, y: y-1}, {x: x+1, y: y-1},
                    {x: x-1, y: y+1}, {x: x+1, y: y+1}
                ];

                for (const pos of checkPositions) {
                    if (pos.x >= 0 && pos.x < TILE_COUNT && 
                        pos.y >= 0 && pos.y < TILE_COUNT &&
                        !this.checkSelfCollision(pos) && 
                        !this.checkSnakeCollision(pos)) {
                        freeCount++;
                    }
                }

                return freeCount;
            }

            // è®¡ç®—æŒ‡å®šæ–¹å‘å‰æ–¹çš„å®‰å…¨ç©ºé—´
            calculateSafeSpace(startX, startY, dx, dy, depth) {
                let safeCount = 0;
                let x = startX;
                let y = startY;

                for (let i = 0; i < depth; i++) {
                    x += dx;
                    y += dy;

                    if (x < 0 || x >= TILE_COUNT || y < 0 || y >= TILE_COUNT) {
                        break;
                    }

                    if (this.checkSelfCollision({x, y}) || this.checkSnakeCollision({x, y})) {
                        break;
                    }

                    safeCount++;
                }

                return safeCount;
            }

            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            isPositionDangerous(x, y) {
                // æ£€æŸ¥è¾¹ç•Œ
                if (x < 0 || x >= TILE_COUNT || y < 0 || y >= TILE_COUNT) {
                    return true;
                }

                // æ£€æŸ¥è‡ªèº«ç¢°æ’
                for (const segment of this.body) {
                    if (segment.x === x && segment.y === y) return true;
                }

                // æ£€æŸ¥ä¸å…¶ä»–è›‡çš„ç¢°æ’
                for (const snake of snakes) {
                    if (snake.id === this.id || !snake.alive) continue;
                    for (const segment of snake.body) {
                        if (segment.x === x && segment.y === y) return true;
                    }
                }

                return false;
            }

            checkSelfCollision(newHead) {
                for (const segment of this.body) {
                    if (segment.x === newHead.x && segment.y === newHead.y) {
                        return true;
                    }
                }
                return false;
            }

            checkSnakeCollision(newHead) {
                for (const snake of snakes) {
                    if (snake.id === this.id || !snake.alive) continue;
                    for (const segment of snake.body) {
                        if (segment.x === newHead.x && segment.y === newHead.y) {
                            return true;
                        }
                    }
                }
                return false;
            }

            applyPowerUp(powerUp) {
                const type = powerUp.type;
                this.createParticles(powerUp.x * GRID_SIZE, powerUp.y * GRID_SIZE, type.color);
                
                switch (type.effect) {
                    case 'speed':
                        this.powerUps.set('speed', Date.now() + type.duration);
                        this.moveDelay = Math.max(50, this.moveDelay * 0.7);
                        break;
                    case 'shield':
                        this.powerUps.set('shield', Date.now() + type.duration);
                        break;
                    case 'golden':
                        this.score += 50;
                        break;
                }
            }

            updatePowerUps() {
                const now = Date.now();
                for (const [effect, endTime] of this.powerUps) {
                    if (now > endTime) {
                        this.powerUps.delete(effect);
                        if (effect === 'speed') {
                            this.moveDelay = this.type === SNAKE_TYPES.AI_BOSS ? 180 : 130;
                        }
                    }
                }
            }

            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    particles.push(new Particle(x + GRID_SIZE/2, y + GRID_SIZE/2, color));
                }
            }

            die() {
                this.alive = false;
                this.createParticles(
                    this.body[0].x * GRID_SIZE, 
                    this.body[0].y * GRID_SIZE, 
                    this.type.color
                );
            }

            draw() {
                if (!this.alive) return;

                // ç»˜åˆ¶æŠ¤ç›¾æ•ˆæœ
                if (this.powerUps.has('shield')) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#ff9ff3';
                    ctx.lineWidth = 3;
                    const head = this.body[0];
                    ctx.strokeRect(
                        head.x * GRID_SIZE - 2,
                        head.y * GRID_SIZE - 2,
                        GRID_SIZE + 4,
                        GRID_SIZE + 4
                    );
                    ctx.restore();
                }

                // ç»˜åˆ¶è›‡èº«
                for (let i = 0; i < this.body.length; i++) {
                    const segment = this.body[i];
                    const x = segment.x * GRID_SIZE;
                    const y = segment.y * GRID_SIZE;
                    const isHead = i === 0;
                    
                    // æ·»åŠ å‘å…‰æ•ˆæœ
                    if (isHead) {
                        ctx.save();
                        ctx.shadowColor = this.type.shadowColor;
                        ctx.shadowBlur = 15;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }

                    // æ ¹æ®è›‡çš„ç±»å‹ç»˜åˆ¶ä¸åŒå½¢çŠ¶
                    ctx.fillStyle = isHead ? this.type.color : this.type.bodyColor;
                    
                    switch (this.type.shape) {
                        case 'round':
                            ctx.beginPath();
                            ctx.arc(x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE/2 - 1, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'square':
                            ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                            break;
                        case 'diamond':
                            ctx.save();
                            ctx.translate(x + GRID_SIZE/2, y + GRID_SIZE/2);
                            ctx.rotate(Math.PI / 4);
                            ctx.fillRect(-GRID_SIZE/3, -GRID_SIZE/3, GRID_SIZE*2/3, GRID_SIZE*2/3);
                            ctx.restore();
                            break;
                        case 'star':
                            this.drawStar(x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE/3);
                            break;
                        default:
                            ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    }

                    // åœ¨å¤´éƒ¨ç»˜åˆ¶çœ¼ç›
                    if (isHead) {
                        ctx.fillStyle = 'white';
                        const eyeSize = 3;
                        ctx.fillRect(x + 4, y + 4, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - 7, y + 4, eyeSize, eyeSize);
                        
                        ctx.fillStyle = 'black';
                        ctx.fillRect(x + 5, y + 5, 1, 1);
                        ctx.fillRect(x + GRID_SIZE - 6, y + 5, 1, 1);
                        
                        ctx.restore();
                    }

                    // é€Ÿåº¦åŠ æˆæ•ˆæœ
                    if (this.powerUps.has('speed') && isHead) {
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = '#00d2d3';
                        for (let j = 0; j < 3; j++) {
                            ctx.fillRect(x - j * 2, y + GRID_SIZE/3, 2, GRID_SIZE/3);
                        }
                        ctx.restore();
                    }
                }
            }

            drawStar(centerX, centerY, radius) {
                const spikes = 5;
                const outerRadius = radius;
                const innerRadius = radius * 0.5;
                
                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
        }

        // æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            snakes = [];
            foods = [];
            powerUps = [];
            particles = [];
            
            // åˆ›å»ºç©å®¶è›‡
            snakes.push(new Snake(5, 5, SNAKE_TYPES.PLAYER, 'player'));
            
            // åˆ›å»ºAIè›‡
            const aiCount = parseInt(elements.snakeCount.value);
            const positions = [
                {x: TILE_COUNT - 6, y: 5, dx: -1, dy: 0},
                {x: 5, y: TILE_COUNT - 6, dx: 0, dy: -1},
                {x: TILE_COUNT - 6, y: TILE_COUNT - 6, dx: -1, dy: 0},
                {x: TILE_COUNT / 2, y: TILE_COUNT / 2, dx: 0, dy: -1},
                {x: 10, y: 10, dx: 1, dy: 0},
                {x: TILE_COUNT - 10, y: 10, dx: -1, dy: 0},
                {x: 10, y: TILE_COUNT - 10, dx: 1, dy: 0},
                {x: TILE_COUNT - 10, y: TILE_COUNT - 10, dx: 0, dy: -1}
            ];
            
            for (let i = 0; i < aiCount; i++) {
                const pos = positions[i % positions.length];
                let type;
                
                if (i === 0) type = SNAKE_TYPES.AI_SMART;
                else if (i === 1) type = SNAKE_TYPES.AI_NEUTRAL;
                else if (i === 2 && gameState.bossMode) type = SNAKE_TYPES.AI_BOSS;
                else type = Math.random() < 0.5 ? SNAKE_TYPES.AI_SMART : SNAKE_TYPES.AI_NEUTRAL;
                
                const snake = new Snake(Math.floor(pos.x), Math.floor(pos.y), type, `ai_${i}`);
                // è®¾ç½®åˆå§‹æ–¹å‘ï¼Œé¿å…ç›´æ¥æœå‘è¾¹ç•Œ
                snake.dx = pos.dx;
                snake.dy = pos.dy;
                snakes.push(snake);
            }
            
            // ç”Ÿæˆåˆå§‹é£Ÿç‰©
            for (let i = 0; i < 5; i++) {
                generateFood();
            }
            
            updateStats();
        }

        // ç”Ÿæˆé£Ÿç‰©
        function generateFood() {
            let x, y;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * TILE_COUNT);
                y = Math.floor(Math.random() * TILE_COUNT);
                attempts++;
            } while (isPositionOccupied(x, y) && attempts < 100);
            
            if (attempts < 100) {
                const isGolden = Math.random() < 0.1;
                foods.push({
                    x: x,
                    y: y,
                    color: isGolden ? '#ffd700' : '#ff6b9d',
                    value: isGolden ? 30 : 10,
                    glow: isGolden
                });
            }
        }

        // ç”Ÿæˆé“å…·
        function generatePowerUp() {
            if (!gameState.powerUpsEnabled || powerUps.length >= 3) return;
            
            if (Math.random() < 0.3) {
                let x, y;
                let attempts = 0;
                
                do {
                    x = Math.floor(Math.random() * TILE_COUNT);
                    y = Math.floor(Math.random() * TILE_COUNT);
                    attempts++;
                } while (isPositionOccupied(x, y) && attempts < 50);
                
                if (attempts < 50) {
                    const types = Object.values(POWER_UP_TYPES);
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    powerUps.push({
                        x: x,
                        y: y,
                        type: type,
                        createdAt: Date.now()
                    });
                }
            }
        }

        // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
        function isPositionOccupied(x, y) {
            // æ£€æŸ¥è›‡èº«
            for (const snake of snakes) {
                if (!snake.alive) continue;
                for (const segment of snake.body) {
                    if (segment.x === x && segment.y === y) return true;
                }
            }
            
            // æ£€æŸ¥é£Ÿç‰©
            for (const food of foods) {
                if (food.x === x && food.y === y) return true;
            }
            
            // æ£€æŸ¥é“å…·
            for (const powerUp of powerUps) {
                if (powerUp.x === x && powerUp.y === y) return true;
            }
            
            return false;
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!gameState.running || gameState.paused) return;
            
            // æ›´æ–°è›‡
            for (const snake of snakes) {
                snake.move();
            }
            
            // æ›´æ–°ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }
            
            // ç”Ÿæˆé“å…·
            generatePowerUp();
            
            // æ¸…ç†è¿‡æœŸé“å…·
            for (let i = powerUps.length - 1; i >= 0; i--) {
                if (Date.now() - powerUps[i].createdAt > 15000) {
                    powerUps.splice(i, 1);
                }
            }
            
            // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
            const aliveSnakes = snakes.filter(snake => snake.alive);
            const playerSnake = snakes.find(s => s.id === 'player');
            
            // åªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µæ‰ç»“æŸæ¸¸æˆï¼š
            // 1. AIå¯¹æˆ˜æ¨¡å¼ä¸‹æ²¡æœ‰å­˜æ´»çš„è›‡
            // 2. æ­£å¸¸æ¨¡å¼ä¸‹ç©å®¶æ­»äº¡ä¸”åªå‰©1æ¡æˆ–0æ¡AIè›‡
            // 3. æ­£å¸¸æ¨¡å¼ä¸‹æ‰€æœ‰è›‡éƒ½æ­»äº¡
            if ((gameState.aiOnly && aliveSnakes.length === 0) ||
                (!gameState.aiOnly && (!playerSnake || !playerSnake.alive) && aliveSnakes.length <= 1) ||
                (!gameState.aiOnly && aliveSnakes.length === 0)) {
                endGame();
                return;
            }
            
            // æ›´æ–°ç»Ÿè®¡
            updateStats();
            
            // æ¸²æŸ“
            render();
        }

        // æ¸²æŸ“æ¸¸æˆ
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼ï¼ˆå¯é€‰ï¼‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶é£Ÿç‰©
            for (const food of foods) {
                const x = food.x * GRID_SIZE;
                const y = food.y * GRID_SIZE;
                
                if (food.glow) {
                    ctx.save();
                    ctx.shadowColor = food.color;
                    ctx.shadowBlur = 10;
                }
                
                ctx.fillStyle = food.color;
                ctx.beginPath();
                ctx.arc(x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                if (food.glow) {
                    ctx.restore();
                }
            }
            
            // ç»˜åˆ¶é“å…·
            for (const powerUp of powerUps) {
                const x = powerUp.x * GRID_SIZE;
                const y = powerUp.y * GRID_SIZE;
                
                ctx.save();
                ctx.shadowColor = powerUp.type.color;
                ctx.shadowBlur = 8;
                ctx.fillStyle = powerUp.type.color;
                
                // æ—‹è½¬æ•ˆæœ
                ctx.translate(x + GRID_SIZE/2, y + GRID_SIZE/2);
                ctx.rotate((Date.now() / 1000) % (Math.PI * 2));
                ctx.fillRect(-GRID_SIZE/3, -GRID_SIZE/3, GRID_SIZE*2/3, GRID_SIZE*2/3);
                ctx.restore();
                
                // ç»˜åˆ¶ç¬¦å·
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerUp.type.symbol, x + GRID_SIZE/2, y + GRID_SIZE/2 + 4);
            }
            
            // ç»˜åˆ¶è›‡
            for (const snake of snakes) {
                snake.draw();
            }
            
            // ç»˜åˆ¶ç²’å­
            for (const particle of particles) {
                particle.draw();
            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const playerSnake = snakes.find(s => s.id === 'player');
            const aiSnakes = snakes.filter(s => s.id.startsWith('ai_'));
            
            elements.playerScore.textContent = playerSnake ? playerSnake.score : 0;
            
            let aiTotal = 0, neutralTotal = 0, bossTotal = 0;
            for (const snake of aiSnakes) {
                if (snake.type === SNAKE_TYPES.AI_SMART) aiTotal += snake.score;
                else if (snake.type === SNAKE_TYPES.AI_NEUTRAL) neutralTotal += snake.score;
                else if (snake.type === SNAKE_TYPES.AI_BOSS) bossTotal += snake.score;
            }
            
            elements.aiScore.textContent = aiTotal;
            elements.neutralScore.textContent = neutralTotal;
            elements.bossScore.textContent = bossTotal;
            
            const aliveCount = snakes.filter(s => s.alive).length;
            elements.aliveCount.textContent = aliveCount;
            
            const totalScore = snakes.reduce((sum, snake) => sum + snake.score, 0);
            if (totalScore > gameState.highScore) {
                gameState.highScore = totalScore;
                elements.highScore.textContent = gameState.highScore;
            }
        }

        // æ¸¸æˆç»“æŸ
        function endGame() {
            gameState.running = false;
            clearInterval(gameState.loop);
            
            // è®¡ç®—ç»“æœ
            const results = snakes.map(snake => ({
                id: snake.id,
                type: snake.type,
                score: snake.score,
                alive: snake.alive
            })).sort((a, b) => b.score - a.score);
            
            // æ˜¾ç¤ºç»“æœ
            let resultHTML = '<h3>æ’è¡Œæ¦œ</h3>';
            results.forEach((result, index) => {
                const typeName = result.id === 'player' ? 'ç©å®¶' : 
                                result.type === SNAKE_TYPES.AI_SMART ? 'AIæ™ºèƒ½è›‡' :
                                result.type === SNAKE_TYPES.AI_NEUTRAL ? 'AIä¸­ç«‹è›‡' :
                                result.type === SNAKE_TYPES.AI_BOSS ? 'AI Bossè›‡' : 'AIè›‡';
                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : '';
                const status = result.alive ? 'å­˜æ´»' : 'æ­»äº¡';
                resultHTML += `<p>${medal} ${index + 1}. ${typeName}: ${result.score}åˆ† (${status})</p>`;
            });
            
            elements.gameResults.innerHTML = resultHTML;
            elements.gameOver.style.display = 'flex';
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            elements.gameOver.style.display = 'none';
            resetGame();
            startGame();
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (!gameState.running || gameState.paused) return;
            
            const playerSnake = snakes.find(s => s.id === 'player');
            if (!playerSnake || !playerSnake.alive) return;
            
            switch (e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if (playerSnake.dy !== 1) {
                        playerSnake.dx = 0;
                        playerSnake.dy = -1;
                    }
                    break;
                case 'arrowdown':
                case 's':
                    if (playerSnake.dy !== -1) {
                        playerSnake.dx = 0;
                        playerSnake.dy = 1;
                    }
                    break;
                case 'arrowleft':
                case 'a':
                    if (playerSnake.dx !== 1) {
                        playerSnake.dx = -1;
                        playerSnake.dy = 0;
                    }
                    break;
                case 'arrowright':
                case 'd':
                    if (playerSnake.dx !== -1) {
                        playerSnake.dx = 1;
                        playerSnake.dy = 0;
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    pauseGame();
                    break;
            }
        });

        // æ¸¸æˆæ§åˆ¶å‡½æ•°
        function startGame() {
            gameState.speed = parseInt(elements.gameSpeed.value);
            gameState.powerUpsEnabled = elements.powerUpEnabled.value === 'true';
            gameState.bossMode = elements.bossMode.value === 'true';
            
            initGame();
            gameState.running = true;
            gameState.paused = false;
            
            if (gameState.loop) clearInterval(gameState.loop);
            gameState.loop = setInterval(gameLoop, gameState.speed);
        }

        function pauseGame() {
            gameState.paused = !gameState.paused;
            if (gameState.paused) {
                clearInterval(gameState.loop);
            } else if (gameState.running) {
                gameState.loop = setInterval(gameLoop, gameState.speed);
            }
        }

        function resetGame() {
            gameState.running = false;
            gameState.paused = false;
            if (gameState.loop) {
                clearInterval(gameState.loop);
                gameState.loop = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            snakes = [];
            foods = [];
            powerUps = [];
            particles = [];
            updateStats();
        }

        function toggleAI() {
            gameState.aiOnly = !gameState.aiOnly;
            const button = event.target;
            button.textContent = gameState.aiOnly ? 'AIå¯¹æˆ˜ (å¼€å¯)' : 'AIå¯¹æˆ˜';
            button.style.background = gameState.aiOnly ? 
                'linear-gradient(45deg, #ff6b6b, #ee5a24)' : 
                'linear-gradient(45deg, #9c88ff, #8c7ae6)';
        }
    </script>
</div>
</body>
</html>